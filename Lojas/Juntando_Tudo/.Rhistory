padrao <- "[A-Z0-9+]+\\s([^,]+),\\s([^-]+)\\s-\\s[A-Z]{2}"
# Extrair bairro e cidade
bairro <- str_match(plus_code, padrao)[,2]
cidade <- str_match(plus_code, padrao)[,3]
# Retornar como uma lista
return(list(bairro = bairro, cidade = cidade))
}
# Função para transformar em "NA" se começar com termos específicos
transformar_para_NA <- function(texto) {
# Verificar se o valor é NA
if (is.na(texto)) {
return("NA")
}
# Lista de termos que devem ser transformados em "NA"
termos_na <- c("^r\\.", "^rua", "^av\\.", "^aven\\.", "^avenida", "^s/n", "^sn", "^na")
# Verificar se o texto começa com algum dos termos (ignorando maiúsculas/minúsculas)
if (any(str_detect(str_to_lower(texto), termos_na))) {
return("NA")
}
return(texto)
}
# Aplicar a função de extração de endereço
dados <- dados %>%
bind_cols(map_dfr(dados$Endereço, extrair_endereco))
View(dados)
# Aplicar a função transformar_para_NA às colunas Bairro e Cidade
dados <- dados %>%
rowwise() %>%
mutate(
Bairro = transformar_para_NA(Bairro),
Cidade = transformar_para_NA(Cidade)
)
# Verificar e corrigir NAs usando o Plus Code, alterando diretamente as colunas existentes
dados <- dados %>%
rowwise() %>%
mutate(
Bairro = ifelse(is.na(Bairro) || Bairro == "NA", extrair_bairro_cidade(Plus_Code)$bairro, Bairro),
Cidade = ifelse(is.na(Cidade) || Cidade == "NA", extrair_bairro_cidade(Plus_Code)$cidade, Cidade)
)
# Aplicar a função transformar_para_NA às colunas Bairro e Cidade
dados <- dados %>%
rowwise() %>%
mutate(
Bairro = transformar_para_NA(Bairro),
Cidade = transformar_para_NA(Cidade)
)
# Carregar pacotes
library(tidyverse)
library(readxl)
library(writexl)
library(stringr)
library(dplyr)
# Definir o caminho da pasta
caminho_pasta <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo"
# Listar todos os arquivos .xlsx na pasta
arquivos <- list.files(caminho_pasta, pattern = "\\.xlsx$", full.names = TRUE)
# Ler todas as planilhas e combiná-las em um único dataframe
dados <- arquivos %>%
map_df(~read_xlsx(.x) %>% mutate(across(everything(), as.character)))
# Filtrar as lojas onde algum desses campos está ausente (NA)
lojas_com_valores_faltantes <- dados %>%
filter(is.na(Bairro) | Bairro == "NA" |
is.na(`Rua/Aven`) | `Rua/Aven` == "NA" |
is.na(Cidade) | Cidade == "NA")
# Exibir as lojas com valores ausentes
print(lojas_com_valores_faltantes)
# Função para extrair informações de endereço
extrair_endereco <- function(Endereço) {
rua_aven <- str_extract(Endereço, "^[^-]+")
bairro <- str_extract(Endereço, "(?<=-\\s)[^,]+")
cidade <- str_extract(Endereço, "(?<=,\\s)[^-]+")
# Verificar se bairro ou cidade contêm números, hífens, texto único 'BA' ou apenas uma letra
if (!is.na(bairro) && (str_detect(bairro, "[0-9,-]") || str_detect(bairro, "^BA$") || str_length(str_trim(bairro)) == 1)) {
bairro <- "NA"
}
if (!is.na(cidade) && (str_detect(cidade, "[0-9,-]") || str_length(str_trim(cidade)) == 1)) {
cidade <- "NA"
}
# Verificar se o bairro está vazio e substituir por "NA"
if (is.na(bairro) || str_trim(bairro) == "") {
bairro <- "NA"
}
return(list(
rua_aven = str_trim(rua_aven),
bairro = str_trim(bairro),
cidade = str_trim(cidade)
))
}
# Função para extrair bairro e cidade do Plus Code
extrair_bairro_cidade <- function(plus_code) {
# Regex para capturar o bairro e a cidade
padrao <- "[A-Z0-9+]+\\s([^,]+),\\s([^-]+)\\s-\\s[A-Z]{2}"
# Extrair bairro e cidade
bairro <- str_match(plus_code, padrao)[,2]
cidade <- str_match(plus_code, padrao)[,3]
# Retornar como uma lista
return(list(bairro = bairro, cidade = cidade))
}
# Função para transformar em "NA" se começar com termos específicos
transformar_para_NA <- function(texto) {
# Verificar se o valor é NA
if (is.na(texto)) {
return("NA")
}
# Lista de termos que devem ser transformados em "NA"
termos_na <- c("^r\\.", "^rua", "^av\\.", "^aven\\.", "^avenida", "^s/n", "^sn", "^na")
# Verificar se o texto começa com algum dos termos (ignorando maiúsculas/minúsculas)
if (any(str_detect(str_to_lower(texto), termos_na))) {
return("NA")
}
return(texto)
}
# Aplicar a extração de endereço diretamente nas colunas já existentes
dados <- dados %>%
rowwise() %>%
mutate(
endereco_extraido = list(extrair_endereco(Endereço)),
`Rua/Aven` = endereco_extraido$rua_aven,
Bairro = endereco_extraido$bairro,
Cidade = endereco_extraido$cidade
) %>%
select(-endereco_extraido)  # Remover a lista de endereço extraído após a alteração
# Aplicar a função transformar_para_NA nas colunas Bairro e Cidade
dados <- dados %>%
mutate(
Bairro = transformar_para_NA(Bairro),
Cidade = transformar_para_NA(Cidade)
)
View(dados)
# Verificar e corrigir NAs usando o Plus Code, alterando diretamente as colunas existentes
dados <- dados %>%
rowwise() %>%
mutate(
Bairro = ifelse(is.na(Bairro) || Bairro == "NA", extrair_bairro_cidade(Plus_Code)$bairro, Bairro),
Cidade = ifelse(is.na(Cidade) || Cidade == "NA", extrair_bairro_cidade(Plus_Code)$cidade, Cidade)
)
View(dados)
View(lojas_com_valores_faltantes)
# Salvar trabalho
write_xlsx(dados, "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas")
# Salvar trabalho
# Salvar trabalho
write_xlsx(dados, "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas")
# Salvar trabalho
write_xlsx(dados, "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas.xlsx")
library(readxl)   # Para ler arquivos .xlsx
library(readxl)   # Para ler arquivos .xlsx
library(httr)     # Para acessar sites
library(rvest)    # Para extrair informações das páginas
library(stringr)  # Para manipulação de strings
library(writexl)  # Para salvar o novo arquivo
# Definir caminho do arquivo
file_path <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Bairro_Loc_Unicas.xlsx"
# Ler a planilha
df <- read_excel(file_path)
# Verificar nomes das colunas
print("Colunas do arquivo:")
print(colnames(df))
# Verificar se a coluna "Website" existe
if (!"site" %in% colnames(df)) {
stop("Erro: A coluna 'Website' não foi encontrada no arquivo. Verifique o nome exato.")
}
# Verificar se a coluna "Website" existe
if (!"Site" %in% colnames(df)) {
stop("Erro: A coluna 'Website' não foi encontrada no arquivo. Verifique o nome exato.")
}
# Criar uma nova coluna para armazenar os e-mails encontrados
df$email <- NA
# Função para buscar e-mails em um site com logs no console
buscar_email <- function(url, index, total) {
if (!is.na(url) & grepl("http", url)) {
cat(sprintf("[%d/%d] Acessando: %s\n", index, total, url))
resultado <- tryCatch({
page <- GET(url, user_agent("Mozilla/5.0")) %>% read_html()
text <- html_text(page)
emails <- str_extract_all(text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")[[1]]
if (length(emails) > 0) {
unique_emails <- paste(unique(emails), collapse = "; ")
cat("   → E-mails encontrados:", unique_emails, "\n")
return(unique_emails)
}
return(NA)  # Retorna NA se não encontrar nada
}, error = function(e) {
cat("   ⚠ Erro ao acessar:", url, "\n")
return(NA)
})
return(resultado)
}
return(NA)
}
#remover linhas sem site
df <- df[!is.na(df$Site) & df$Site != "", ]  # Remove linhas sem site
# Aplicar a função na coluna Website com progresso
total_sites <- nrow(df)
df$email <- mapply(buscar_email, df$Site, seq_len(total_sites), MoreArgs = list(total = total_sites))
# Salvar novo arquivo XLSX
output_path <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Unindo_coord_com_emails.xlsx"
write_xlsx(df, output_path)
View(df)
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(file_path)
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel(output_path)
# Verificar se as colunas "Loja" e "Bairro" estão presentes no dataframe final
if (!all(c("Loja", "Bairro", "email") %in% colnames(df_com_emails))) {
stop("Erro: As colunas 'Loja', 'Bairro' e 'email' devem estar presentes no arquivo final.")
}
# Preencher e-mails faltantes com base na correspondência entre "Loja" e "Bairro"
for (i in 1:nrow(df_com_emails)) {
if (is.na(df_com_emails$email[i])) {
loja <- df_com_emails$Loja[i]
bairro <- df_com_emails$Bairro[i]
# Verificar se há outra loja com o mesmo "Loja" e "Bairro" que tenha um email
match_email <- df_com_emails[!is.na(df_com_emails$email) & df_com_emails$Loja == loja & df_com_emails$Bairro == bairro, "email"]
if (length(match_email) > 0) {
# Se encontrado, preencher o e-mail
df_com_emails$email[i] <- match_email[1]
}
}
}
# Remover lojas duplicadas com base nas colunas "Loja" e "email"
df_com_emails <- df_com_emails[!duplicated(df_com_emails[, c("Loja", "email")]), ]
View(match_email)
View(df_original)
# Remover lojas duplicadas com base nas colunas "Loja" e "email"
df_original <- df_com_emails[!duplicated(df_com_emails[, c("Loja", "email")]), ]
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(file_path)
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel(output_path)
# Verificar se as colunas "Loja" e "Bairro" estão presentes no dataframe final
if (!all(c("Loja", "Bairro", "email") %in% colnames(df_com_emails))) {
stop("Erro: As colunas 'Loja', 'Bairro' e 'email' devem estar presentes no arquivo final.")
}
# Preencher e-mails faltantes com base na correspondência entre "Loja" e "Bairro"
for (i in 1:nrow(df_com_emails)) {
if (is.na(df_com_emails$email[i])) {
loja <- df_com_emails$Loja[i]
bairro <- df_com_emails$Bairro[i]
# Verificar se há outra loja com o mesmo "Loja" e "Bairro" que tenha um email
match_email <- df_com_emails[!is.na(df_com_emails$email) & df_com_emails$Loja == loja & df_com_emails$Bairro == bairro, "email"]
if (length(match_email) > 0) {
# Se encontrado, preencher o e-mail
df_com_emails$email[i] <- match_email[1]
}
}
}
View(df)
View(df_com_emails)
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(file_path)
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel(output_path)
df_original$email
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(file_path)
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(file_path)
# Recarregar o arquivo inicial após a criação do arquivo com os e-mails
df_original <- read_excel(Lojas_Bairro_Loc_Unicas)
# Carregar o arquivo original
df_original <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Bairro_Loc_Unicas.xlsx")
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Unindo_coord_com_emails.xlsx")
df$`email` <- NA  # Cria a coluna com valores ausentes (NA)
df_original$`email` <- NA
# Carregar os dataframes
df_original <- read_excel(file_path)
df_com_emails <- read_excel(output_path)
# Verificar se ambas as colunas "Loja" e "Bairro" existem em ambos os dataframes
df_original$Loja <- as.character(df_original$Loja)
df_original$Bairro <- as.character(df_original$Bairro)
df_com_emails$Loja <- as.character(df_com_emails$Loja)
df_com_emails$Bairro <- as.character(df_com_emails$Bairro)
# Realizar a junção dos dataframes com base nas colunas "Loja" e "Bairro"
df_original <- merge(df_original, df_com_emails[, c("Loja", "Bairro", "email")],
by = c("Loja", "Bairro"),
all.x = TRUE)
# Visualizar o resultado final
head(df_original)
View(df_original)
# Carregar o arquivo original
df_original <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Bairro_Loc_Unicas.xlsx")
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Unindo_coord_com_emails.xlsx")
# Verificar se ambas as colunas "Loja" e "Bairro" existem em ambos os dataframes
df_original$Loja <- as.character(df_original$Loja)
df_original$Bairro <- as.character(df_original$Bairro)
df_com_emails$Loja <- as.character(df_com_emails$Loja)
df_com_emails$Bairro <- as.character(df_com_emails$Bairro)
# Realizar a junção dos dataframes com base nas colunas "Loja" e "Bairro"
df_original <- merge(df_original, df_com_emails[, c("Loja", "Bairro", "email")],
by = c("Loja", "Bairro"),
all.x = TRUE)
# Visualizar o resultado final
head(df_original)
View(df_original)
# Salvar o arquivo final com as modificações
write_xlsx(df_original, output_path)
# Salvar o arquivo final com as modificações
output_path <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
write_xlsx(df_original, output_path)
# Carregar o arquivo original (preciso atualizar esse endereço no futuro)
df_original <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Bairro_Loc_Unicas.xlsx")
# Carregar o arquivo finalizado com e-mails
df_com_emails <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Unindo_coord_com_emails.xlsx")
df_original$`email` <- NA
# Verificar se ambas as colunas "Loja" e "Bairro" existem em ambos os dataframes
df_original$Loja <- as.character(df_original$Loja)
df_original$Bairro <- as.character(df_original$Bairro)
df_com_emails$Loja <- as.character(df_com_emails$Loja)
df_com_emails$Bairro <- as.character(df_com_emails$Bairro)
# Realizar a junção dos dataframes com base nas colunas "Loja" e "Bairro"
df_original <- merge(df_original, df_com_emails[, c("Loja", "Bairro", "email")],
by = c("Loja", "Bairro"),
all.x = TRUE)
# Visualizar o resultado final
head(df_original)
# Visualizar o resultado final
head(df_original)
# Carregar o arquivo original (preciso atualizar esse endereço no futuro)
df_original <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Bairro_Loc_Unicas.xlsx")
# Carregar pacotes
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
library(writexl)
library(tidyr)
# Definir API Key da HERE Maps
api_key <- "8__EX014cinJzotz2TuJPXeoWKB9v_ZnPQjiR-3lJvA"
# Função para geocodificação usando a API da HERE Maps
geocode_here <- function(endereco) {
if (is.na(endereco) || endereco == "") return(NA)  # Evita chamadas desnecessárias
url <- paste0("https://geocode.search.hereapi.com/v1/geocode?q=",
URLencode(endereco), "&apiKey=", api_key)
resposta <- GET(url)
if (status_code(resposta) == 200) {
dados <- content(resposta, as = "parsed", type = "application/json")
if (length(dados$items) > 0) {
return(dados$items[[1]]$position)  # Retorna as coordenadas completas
}
}
return(NA)
}
# Caminho do arquivo
arquivo_xlsx <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
# Leia o arquivo
dados <- read_excel(arquivo_xlsx)
# Leia o arquivo
dados <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# Leia o arquivo
dados <- read_excel"C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
# Leia o arquivo
dados <- read_excel("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# Leia o arquivo
dados <- read_excel("C:\\Users\\leona\\Github\\Web-Scraping-Maps-Rstudio\\Lojas\\Juntando Tudo\\Lojas_Unidas_Unicas__Loc_emails.xlsx")
caminho <- normalizePath("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
caminho <- normalizePath("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
file.exists("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# Caminho do arquivo
arquivo_xlsx <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
file.exists("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# Carregar pacotes
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
library(writexl)
library(tidyr)
# Definir API Key da HERE Maps
api_key <- "8__EX014cinJzotz2TuJPXeoWKB9v_ZnPQjiR-3lJvA"
# Função para geocodificação usando a API da HERE Maps
geocode_here <- function(endereco) {
if (is.na(endereco) || endereco == "") return(NA)  # Evita chamadas desnecessárias
url <- paste0("https://geocode.search.hereapi.com/v1/geocode?q=",
URLencode(endereco), "&apiKey=", api_key)
resposta <- GET(url)
if (status_code(resposta) == 200) {
dados <- content(resposta, as = "parsed", type = "application/json")
if (length(dados$items) > 0) {
return(dados$items[[1]]$position)  # Retorna as coordenadas completas
}
}
return(NA)
}
# Caminho do arquivo
arquivo_xlsx <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
file.exists("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# **Aplicar a geocodificação SOMENTE onde a coluna "Loc" está vazia**
dados_geo <- dados %>%
mutate(coord = ifelse(is.na(Loc),
list(geocode_here(`Endereço`)),
list(Loc))) %>%
unnest_wider(coord, names_sep = "_") %>%
rename(latitude = lat, longitude = lng)
# Carregar pacotes
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
library(writexl)
library(tidyr)
# Definir API Key da HERE Maps
api_key <- "8__EX014cinJzotz2TuJPXeoWKB9v_ZnPQjiR-3lJvA"
# Função para geocodificação usando a API da HERE Maps
geocode_here <- function(endereco) {
if (is.na(endereco) || endereco == "") return(NA)  # Evita chamadas desnecessárias
url <- paste0("https://geocode.search.hereapi.com/v1/geocode?q=",
URLencode(endereco), "&apiKey=", api_key)
resposta <- GET(url)
if (status_code(resposta) == 200) {
dados <- content(resposta, as = "parsed", type = "application/json")
if (length(dados$items) > 0) {
return(dados$items[[1]]$position)  # Retorna as coordenadas completas
}
}
return(NA)
}
# Caminho do arquivo
arquivo_xlsx <- "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx"
file.exists("C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Lojas_Unidas_Unicas__Loc_emails.xlsx")
# **Aplicar a geocodificação SOMENTE onde a coluna "Loc" está vazia**
dados <- read_xlsx(arquivo_xlsx)
# Agora, o código que você forneceu deve funcionar corretamente
dados_geo <- dados %>%
mutate(coord = ifelse(is.na(Loc),
list(geocode_here(`Endereço`)),
list(Loc))) %>%
unnest_wider(coord, names_sep = "_") %>%
rename(latitude = lat, longitude = lng)
# Aplicando geocodificação somente onde a coluna "Loc" está vazia
dados_geo <- dados %>%
rowwise() %>%  # Processar linha por linha
mutate(coord = ifelse(is.na(Loc),
list(geocode_here(`Endereço`)),
list(Loc))) %>%
unnest_wider(coord, names_sep = "_") %>%
rename(latitude = lat, longitude = lng) %>%
ungroup()  # Remover o agrupamento após o mutate
# Carregar pacotes
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
library(writexl)
library(tidyr)
# Definir API Key da HERE Maps
api_key <- "8__EX014cinJzotz2TuJPXeoWKB9v_ZnPQjiR-3lJvA"
# Função para geocodificação com mensagens de progresso
geocode_here <- function(endereco, idx) {
if (is.na(endereco) || endereco == "") return(NA)  # Evita chamadas desnecessárias
# Mensagem de progresso
cat(paste("Processando endereço", idx, ":", endereco, "\n"))
url <- paste0("https://geocode.search.hereapi.com/v1/geocode?q=",
URLencode(endereco), "&apiKey=", api_key)
resposta <- GET(url)
if (status_code(resposta) == 200) {
dados <- content(resposta, as = "parsed", type = "application/json")
if (length(dados$items) > 0) {
return(dados$items[[1]]$position)  # Retorna as coordenadas completas
}
}
return(NA)
}
# Carregar os dados do arquivo
dados <- read_xlsx(arquivo_xlsx)
# Aplicar a geocodificação SOMENTE onde a coluna "Loc" está vazia com mensagens de progresso
dados_geo <- dados %>%
rowwise() %>%  # Processar linha por linha
mutate(coord = ifelse(is.na(Loc),
list(geocode_here(`Endereço`, row_number())),  # Adiciona índice para progresso
list(Loc))) %>%
unnest_wider(coord, names_sep = "_") %>%
rename(latitude = coord_lat, longitude = coord_lng) %>%  # Renomeando as colunas corretamente
ungroup()  # Remover o agrupamento após o mutate
# Identificar falhas após a primeira tentativa
dados_na <- dados_geo %>%
filter(is.na(latitude) | is.na(longitude))
View(dados_geo)
View(dados_geo)
# Função para excluir a coluna coord_1
remover_coord_1 <- function(dados) {
dados <- dados %>%
select(-coord_1)  # Remove a coluna coord_1
return(dados)
}
View(dados_geo)
# Aplicar a função no DataFrame 'dados_geo'
dados_geo <- remover_coord_1(dados_geo)
# Função para combinar latitude e longitude na coluna Loc
combinar_lat_lon_em_loc <- function(dados) {
dados <- dados %>%
mutate(Loc = paste(latitude, longitude, sep = ", "))  # Cria a coluna Loc no formato "latitude, longitude"
return(dados)
}
View(dados_geo)
# Função para combinar latitude e longitude na coluna Loc, apenas se estiver vazia
combinar_lat_lon_em_loc <- function(dados) {
dados <- dados %>%
mutate(Loc = ifelse(is.na(Loc) | Loc == "", paste(latitude, longitude, sep = ", "), Loc))  # Só preenche se Loc estiver vazio
return(dados)
}
# Aplicar a função no DataFrame 'dados_geo'
dados_geo <- combinar_lat_lon_em_loc(dados_geo)
# Remover as colunas latitude e longitude
dados_geo <- dados_geo %>%
select(-latitude, -longitude)
# Salvar o resultado atualizado
write_xlsx(dados_geo, "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando Tudo/Atualizando_here_coord.xlsx")
# Salvar o resultado atualizado
write_xlsx(dados_geo, "C:/Users/leona/Github/Web-Scraping-Maps-Rstudio/Lojas/Juntando_Tudo/Atualizando_here_coord.xlsx")
